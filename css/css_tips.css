/* блокам разметки задаются только размеры и внешние отступы; внутренние отступы добавляются дополнительным элементам, вложенным в ячейки сетки;
такой подход упрощает расчет сеток;
блочная модель устроена таким образом, что общий размер элемента складывается из ширины/высоты, маргинов и паддингов, а также ширины рамок,
поэтому, чтобы получить правильные размеры блоков сетки, всегда нужно помнить об этом.
Если же блокам сетки задавать только ширину и внешние отступы, то слагаемых становится намного меньше, а шанс совершить ошибку уменьшается. */

/* свойства для обработки текста почти все шрифтовые конфигурации наследуемые */
.hit + .miss, /* соседние: применит стили к .miss, если сразу перед ним есть .hit */
.player-1 .hit + .miss, /* комбинируем: .miss, если перед ним .hit, и оба вложены в .player-1 */
ul > li, /* дочерние: li - вложен в ul */
ul > li > span, /* потомки: span и li для ul, контекстные селекторы влияют на всех потомков, ограничиваем как выше указано */
a:visited, /* псевдоклассы: посещённые ссылки в ссылках важен порядок: link, visited, hover, actve */
a:active, /* псевдоклассы: кнопка мыши зажата на ссылке */
a:link, /* псевдоклассы: не посещённые ссылки */
li:last-child, /* псевдокласс first-child/last-child - первый/последний дочерний элемент родителя, выберет последний элемент списка */
.alert:hover,  /* псевдокласс hover - наведён курсор мыши и кнопка мыши не нажата */
form input:focus, /* в данный момент в фокусе, пример - текстовое поле, в которое установлен курсор, находится в фокусе, могут быть и ссылки и т.д. */
li.top:hover ul.submenu, /* для выпадающих меню */
li:nth-child(2), /* псевдокласс nth-child(число или формула) выберет теги по порядковому номеру */
.shooter-2 li:nth-child(3), /* можно комбинировать и так */
input[checked], /* селектор атрибутов */
input[type="text"] /* тоже вариант селектора атрибутов */
#some-id /* селектор по id, использовать в крайних случаях, считается плохой практикой */ {
  font: [font-style||font-variant||font-weight||font-stretch] font-size [/line-height] font-family;
  font-size: 1.5em/20px/15pt/80%; /* =ширине буквы М в данном шрифте/пиксели/пункты/проценты, слова типа small/large обычно не используют */
  font-family: "PT Sans", "Arial", serif; /* "редкий", "похожий", желаемый тип; Times New Roman - конкретное название шрифта,
  serif - с засечками, sans-serif - без засечек */
  font-weight: normal/bold/bolder/lighter/100; /* толщина начертания, цифры от 100 до 900 задают толщину */
  font-style: italic/normal;
  color: #FF9900/green/rgb(255, 255, 0);
  text-decoration: line-through/underline/overline/none; /* перечеркнутый/подчеркнутый/черта сверху */
  text-transform: lowercase/uppercase/capitalize/none; /* регистр символов все строчные/все прописные/каждое слово с прописной/ничего */
  white-space: nowrap/pre/pre-wrap/normal; /* управление пробелами: текст одной строкой без переносов/аналогично <pre>/как pre, но добавляет
  автоматические переносы, если текст не помещается в контейнер/по умолчанию */
  text-align: left/right/center/justify; /* выравнивание текста по-горизонтали */
  vertical-align: top/middle/bottom/baseline; /* вертикальное вырав: по верхнему краю строки/по середине/по нижнему/по базовой линии (по умолч) */
  line-height: 1.5/150%/12px/2em/normal; /* межстрочный интервал: множитель/%/пиксели/=М/автоматически (лучше множитель или относительные) */
}

/* вертикальный ритм текста - для улучшения восприятия текста, чтобы сохранить вертикальный ритм и хорошую читабельность текста при любом
размере шрифта, нужно задавать размеры шрифта, межстрочный интервал и вертикальные отступы между заголовками и абзацами в относительных единицах.
Тогда, как бы пользователь ни изменял размер шрифта, ваш текст останется читабельным и удобным для восприятия. */

/* декоративное подчеркивание */
.class {
  text-decoration: none;
  color: green;
  border-bottom: 1px dashed green;
}

.class:hover {
  border-bottom: none;
}

/* верхние и нижние индексы (аналог html <sup> и <sub>) */
.sub {
  vertical-align: sub/super;
  font-size: 0.5em;
}

/* свойства для задания размеров и отступов */
p {
  display: block; /* определяет тип элемента (блочный и другие) */
  margin-left: 50px;
  padding: 20px; /* отступы внутри элемента */
  width: 50%;
  position: absolute; /* для «многослойных» интерфейсов: вспл окна, галереи, мелкие декор элементы, absolute - выключаются из потока */
  top: 10px; /* управляют расположением элемента */
  right: 10px;
  bottom: 100px;
  left: 10px;
  z-index: auto; /* управляет порядком слоёв */
}

/* создание сетки страницы */
footer {
  float: left;
  clear: both;
}

/* блочная модель; область, занимаемая блочным элементом:
- ширина и высота содержания (width и height)
- внутренние (padding) и внешние (margin) отступы
- ширина рамок (border) */

/* Ширина полей ввода определяется значением атрибута size; width: auto для полей ввода рассчитывается из значения size по умолчанию
и не растягивает поля на всю ширину контейнера. */
div {
  width: 100px/auto; /* по умолчанию (auto) блочные элементы занимают всю доступную ширину (равна ширине родительского контейнера или окна браузера)
  задает не общую ширину, а только ширину содержания, общая ширина блока складывается: ширина содержания, padding, border;
  поведение элемента может зависит:
  - по умолчанию, соответствует значению width: auto; - блок занимает всю ширину родительского блока, если есть внутренние отступы или рамки,
    то его ширина содержания автоматически уменьшается, а общая ширина остается равной ширине родителя
  - ширина блока задана явно, например, width:100%; - ширина содержания блока равна ширине родительского блока, если добавить внутренние отступы и рамки,
    то его общая ширина становится больше ширины родителя */
  height: 100px/auto; /* высота по умолчанию зависит от содержимого. */
  min-height: 50px; /* минимальная высота */
  padding: 10px; /* внутренние отступы, для строчных не задавать (ведут себя непредсказуемо), одинаковые со всех сторон */
  padding: 5px 10px; /* сверху и снизу 5, справа и слева 10 */
  padding: 5px 10px 15px; /* сверху 5, слева и справа 10, снизу 15 */
  padding: 5px 10px 15px 20px; /* верх 5, право 10, низ 15, лево 20 */
  padding-top: 20px;
  padding-right: 20px;
  padding-bottom: 20px;
  padding-left: 20px;
  /* Выпадание эффект с вертикальными внешними отступами: если внутри родительского блока расположить блок и задать ему отступ сверху,
  то внутренний блок прижмется к верхнему краю родительского, а у родительского элемента появится отступ сверху.
  Т.е. верхний отступ внутреннего элемента «выпадает» из родительского элемента. Если у родительского элемента тоже был задан внешний отступ,
  то выберется максимальный отступ между собственным и «выпавшим». Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу
  внутренний отступ (паддинг) сверху или добавить рамку сверху. Внешние и внутренние отступы всегда складываются. */
  margin: 10px; /* внешние отступы, строчные реагируют только на горизонтальные отступы */
  margin: 5px 10px; /* верх и низ 5, право и лево 10 */
  margin: 5px 10px 15px; /* верх 5, право и лево 10, низ 15 */
  margin: 5px 10px 15px 20px; /* верх, право, низ, лево */
  margin-top: 20px; /* вертикальный между соседями схлопывается (40 и 20, выберет 40) */
  margin-right: 20px; /* горизонтальные складываются (40 и 20, выберет 60) */
  margin-bottom: 20px;
  margin-left: 20px;
  border: [bw] [bs] [bc]; /* рамка, можно задавать и блочным, и строчным */
  border-width: 5px; /* ширина рамки */
  border-style: solid; /* solid - сплошная; dashed - пунктиром; dotted - точками */
  border-color: red; /* цвет рамки */
  box-sizing: content-box/border-box; /* значение по умолчанию, соответствует стандартной блочной модели/изменяет режим расчета ширины
  http://simonenko.su/32197993404/use-css3-box-sizing статья про свойство */
  display: block/inline/inline-block/table/table-row/table-cell/none; /* меняет тип элемента; inline-block - блочно-строчные:
  - им можно задавать размеры, рамки и отступы, как и блочным;
  - их ширина по умолчанию зависит от содержания, а не растягивается на всю ширину контейнера;
  - они не порождают принудительных переносов строк, могут располагаться на одной строке, пока помещаются в родительский контейнер;
  - элементы в одной строке выравниваются вертикально подобно строчным;
  - реагируют на горизонтальное выравнивание, text-align, заданное у родителя.
  - часто используют для создания декоративных элементов: кнопок, плашек, блочков
  - с их помощью создают различные списки товаров в каталогах
  - для сеток страниц эти элементы используются реже (их не поддерживают старые браузеры, например, IE7 и младше)
    https://htmlacademy.ru/blog/21-fighting-the-space-between-inline-block-elements
    http://css-live.ru/articles/zagadochnye-otstupy-mezhdu-inlajn-blokami.html
    Бороться с пробелом после блочно-строчных можно несколькими способами:
      - удалять пробелы в коде;
      - обнулять размер шрифта font-size: 0; (не работает, если вы используете относительные размеры шрифта);
      - играться с маргинами после блочно-строчного (размер пробела может быть разным в разных шрифтах, может меняться при изменении размера шрифта).
  - явно задаем vertical-align;
  - float перебивает display (float включаем, display не работает)
  none - не отображать элемент, не занимает места на странице, применяется при создании выпадающих меню, динамических галерей,
  переключающихся вкладок и много где еще (visibility: hidden; прячет элемент, но он занимает место на странице) */
}

/* Чтобы отцентровать блочный элемент, нужно выполнить следующие действия: Задать элементу ширину, которая меньше ширины родительского контейнера.
Задать для внешних отступов справа и слева значение auto. */

.selector {
    width: 100px;
    margin: 0 auto;
}

.selector {
    width: 100px;
    margin-left: auto;
    margin-right: auto;
}

/* строчные элементы не меняют своей ширины и высоты от рамок и т.д. */

/* сетки и управление потоком */
/* cетка — взаимное расположение крупных блоков сайта (сетка - это нечто крупное) */
/* поток — порядок отображения элементов на странице (как браузер отрисовывает):
по умолчанию блочные элементы - прямоугольные области, идущие друг за другом сверху вниз
строчные элементы - сверху вниз и слева направо и при необходимости переносятся на новую строку */
/* способы управления потоками и построения сетки:
- флоаты - самый распространенный способ построения сеток
- инлайн-блоки;
- табличная вёрстка - устаревший
- флексбоксы - новая и очень мощная технология для построения сеток, её поддержка браузерами ещё достаточно слабая */

.column {
  float: left/right/none; /* прижимает к левому/правому краю родителя, другие элементы обтекают его справа/слева, по центру нельзя
  - ужимается до ширины содержимого
  - если флоатим строчный, он начинает вести себя как блочный
  - зафлоаченные элементы частично выпадают из потока:
    - блочные элементы после зафлоаченного перестают его замечать, подтягиваются вверх и занимают его место, как будто его и нет
      (эффект прохождения сквозь блоки, когда зафлоаченный элемент выше, чем несколько последующих за ним блоков)
      (эффект выпаданий из родителя, когда все дочерние блоки в родителе зафлоачены, родитель схлопывается по высоте, как будто в нём
      нет содержимого, а блоки выпадают из него)
    - строчные элементы после зафлоаченного блока, начинают обтекать его со свободной стороны
  - идущие друг за другом флоаты выстраиваются в ряд, пока им хватает свободного места, затем переносятся на следующую строчку
  - при переходе на новую строку ведут себя по-разному! */
  clear: both/left/right/none; /* запрещает обтекание, избавляемся от "наезжания"
  если после флоатного элемента расположен элемент с запрещённым обтеканием, то последний опускается под флоатный */
}

/* распорка, чтобы убрать эффект выпадания флоатов */
.clearfix {
  clear: both;
}

/* псевдораспорка, clearfix добавляется к контейнеру, внутри которого лежат флоатные колонки, после этого в контейнер не нужно добавлять
дополнительный элемент-распорку, т. к. распорка создаётся с помощью псевдоэлемента */
.clearfix::after {
    content: "";
    display: table;
    clear: both;
}

/* позиционирование */
.some-class {
  position: static/relative/absolute/fixed; /* по умолчанию/относительное (можно перемещать относительно исходного положения), смещается иллюзорная копия
  absolute:
  - выпадают из потока документа; место, которое они занимали, становится как бы пустым и его занимают соседние элементы
  - ширина по умолчанию зависит от содержимого (а не растягивается на всю доступную ширину)
  - остаются на том же месте, где были, если не заданы значения свойств top, left, right, bottom
  - строчный будет вести себя как блочный (можно задать и ширину, и высоту)
  - left, top, right и bottom задают расположение относительно некой системы координат, как для точки на графике, по умолчанию такой системой
    координат является окно браузера, а точки начала координат привязаны к его углам: свойство left задает отступ от левого края окна браузера
    до левого края абсолютно спозиционированного элемента, если свойству задать отрицательное значение, то элемент сместится за левый край браузера
    (при этом полоса прокрутки не появится)
    Если какой-нибудь из родителей «абсолютного» элемента имеет относительное позиционирование, то элемент будет позиционироваться относительно
    этого родителя. Если среди родителей несколько относительно позиционированных элементов, то «абсолютный» элемент будет позиционироваться
    относительно ближайшего из них. Позиционирование по умолчанию отличается от позиционирования внутри тега body
    Неявная точка отсчета — это то место, где находился элемент до того, как ему задали абсолютное позиционирование. Если «абсолютному» элементу
    не задавать свойства left - bottom, то он выпадет из потока, но останется на прежнем месте; такой элемент можно сместить из неявной точки
    отсчета с помощью свойства margin. Оно будет работать примерно так же, как и свойства left - bottom для «относительного» элемента. Когда значение
    для left и др не задано, оно равно auto. С помощью значения auto можно возвращать «абсолютные» элементы на исходное положение
  fixed:
  - выпадает из потока
  - привязывается к определенной точке в окне браузера и остается на ней всегда, даже при прокрутке страницы
  - можно позиционировать с помощью свойств top, left, right, bottom, но точка отсчета всегда привязана к окну браузера
  - часто применяют для создания навигационных панелей, привязанных к верхней или нижней части окна браузера */
  top/bottom: 10px/-10px; /* позволяет сместить относительно спозиционированный элемент вверх или вниз относительно его исходного положения, обычно
  задается в пикселях, но можно использовать и другие единицы измерения CSS */
  left/right: 10px/-10px; /* влево-вправо относительно исходного */
  z-index: 100; /* по умолчанию выше оказывается тот блок, который расположен дальше в коде страницы, это свойство меняет порядок:
  - целое число
  - чем больше z-index, тем выше располагается блок
  - работает для элементов, у которых position: absolute/fixed/relative */
}

/* декоративные свойства */
.some-class {
  background-color: #dff0d8;
  color: #468847; /* цвет шрифта */
  border-radius: 5px; /* закругление рамки */
}

/* создаем меню, стили надо задавать для всех состояний ссылок! */
.main-menu {
  padding: 0px; /* обнуляем внутренние и внешние отступы */
  margin: 0px;
  list-style: none; /* сбрасываем маркеры */
  border: 1px solid #e5e5e5; /* используем любые оформляшки для меню
  простейший способ оформить пункты меню — добавить между ними отступы и задать стили ссылок; хорошим тоном считается задавать стили ссылок
  для всех состояний: по умолчанию, посещенная, при наведении и щелчке; но для этого дизайнер должен продумать и отрисовать все состояния ссылок;
  мы используем контекстные селекторы, перед каждым CSS-правилом, относящимся к меню, мы пишем класс меню;
  такой способ называется созданием пространства имен; он позволяет эффективно отделять друг от друга стили, относящиеся к разным блокам */
}

.main-menu li {
  margin: 0;
}

.main-menu a {
  display: block;
  color: #0088cc;
  padding: 8px 10px;
  border: 1px solid #e5e5e5;
  margin-bottom: -1px; /* убираем двойную рамку */
}

.main-menu .active a,
.main-menu > .active > a /* так, чтобы не все подсвечивались, а только верхний */ {

}

/* горизонтальное меню
особенность: иногда все пункты меню не влезают в одну строку; главное правило — ссылки в меню должны быть доступны и видимы при любых обстоятельствах
уменьшить вред от этого эффекта, сделать так, чтобы пункты меню переносились на новую строку целиком, запретив переносы текста внутри них
выпадающее вертикальное из горизонтального - абсолютное и относительное позиционирование
- элементам списка li верхнего уровня задают относительное позиционирование
- выпадающего меню — абсолютное
- выпадающее подменю располагают в том месте, куда оно будет «выпадать» (лучше, чтобы оно немного «нависало» над родительским пунктом)
- нужно установить для подменю z-index больше, чем у родительских пунктов, чтобы подменю располагалось выше и перекрывало их при появлении
- так как абсолютное позиционирование сбрасывает ширину, то можно установить ширину для подменю
- добавление интерактивности: прячем выпадающее подменю по умолчанию display: none; при наведении появлялось :hover и display: block;

горизонтальное меню, вертикальные выпадающие подменю:
- задаем режимы позиционирования,
- стили для подменю
- механизм выпадания
- надо изменить селектор .main-menu li на .main-menu > li, чтобы блочно-строчными были только элементы списка верхнего уровня

выпадающее подменю открыто по умолчанию (а не только при наведении мыши):
- к элементу списка в меню верхнего уровня, где должно быть открыто подменю, добавим класс opened
- используем селектор: .main-menu .opened .sub-menu, в нём пропишем свойство, которое отображает подменю
- чтобы выделить сам пункт меню с открытым подменю, можно использовать .main-menu > .opened > a, «ссылка, которая лежит в элементе с классом opened» */
.main-menu li {
  display: inline-block;
}

.main-menu a {
  display: block;
  padding 5px;
}

.main-menu li {
  white-space: nowrap;
}

.main-menu .sub-menu {
    display: none;
    position: absolute;
    top: 5px;
    left: 170px;
    z-index: 10;
    width: 150px;
    margin: 0;
    padding: 0;
    list-style: none;
    background: #fcf8e3;
}

.main-menu > li:hover .sub-menu {
    display: block;
}

/* что делаем для горизонтального меню */

.main-menu {
    margin: 0;
    padding: 0;
    list-style: none;
    border: 1px solid #e5e5e5;
}

.main-menu li {
    display: inline-block;
    margin-right: 5px;
}

.main-menu a {
    display: block;
    padding: 8px 10px;
    color: #0088cc;
    background-color: #f5f5f5;
}

/* свойства для обработки таблиц */
table {
  border: 3px solid black; /* прочерчены все линии таблицы 3px - ширина границы */
  border-top: black; /* убираем border, тогда только для отдельных линий границы */
  border-right: black;
  border-bottom: black;
  border-left: black;
  border-collapse: collapse/separate; /* схлопывание соседних рамок/расклеивает ячейки, тогда можно использовать отступы между ними */
  border-spacing: 2px; /* отступы между рамками, задается для table */
  background-color: black;
  color: black; /* цвет текста */
  border-color: black; /* border: 3px solid black; - компактная форма задания всех параметров для границ */
  width: 100px/50%/auto; /* % - от родительского элемента (окно браузера), auto - по умолчанию, нельзя сжать сильнее содержимого */
  height: 100px/50%/auto; /* % при задании высоты обычно не работают, ширину и высоту можно задавать и для ячеек,
  можно в коде html <th style="width: 70%;"> */
}

td {
  text-align: left/right/center;
  vertical-align: top/middle/bottom;
  padding: 10px; /* td внутренние отступы элемента, можно группировать общее и отдельное свойства задается для td */
  padding-top: 20px;
  padding-right: 20px;
  padding-bottom: 20px;
  padding-left: 20px;
}

caption {
  caption-side: top; /* или bottom - для положения заголовка таблицы по вертикали */
  text-align: left; /* right и center для выравнивания по-горизонтали */
}

/* декоративное оформление: фоны */
.someselector {
  background-color: red;
  background-image: url("адрес-картинки"); /* можно и фон, и картинку, картинка ляжет поверх фона */
  background-image: linear-gradient(to bottom, #2ecc71, #f1c40f); /* градиентная заливка */
  background-repeat: repeat/repeat-x/repeat-y/no-repeat; /* повторять (по умолчанию)/по-горизонтали/по-вертикали/не повторять;
  repeat, repeat-x или repeat-y часто используется для создания декоративных эффектов: стежки; зазубренные края; градиенты и тени.
  Да, сейчас уже градиенты и тени можно делать с помощью CSS. Но иногда, когда тень или градиент достаточно сложные, проще использовать
  полупрозрачный PNG. Самое главное при создании таких эффектов — выбрать картинку с нужным периодом. Она может быть очень маленькой и даст
  существенную экономию веса страницы. */
  background-position: x y; /* x: left/center/right/%/px y: top/center/bottom/%/px 50% 50% - по центру, 50px слева 100px сверху,
  если фон больше блока, то управлять отображаемой частью будет это же свойство */
  background-attachment: fixed/scroll; /* не прокручивается/прокручивается(по умолчанию) */
  background: [bc] [bi] [br] [bp] [bs] [ba]; /* обозначения: color image repeat position attachment, если не указано, исп по умолчанию */
}

/* несколько фонов (фон в фоне) */
/* старый способ: вкладываем элементы друг в друга и делаем их одинакового размера, затем каждому элементу задаём свой фон: каждый элемент служит
одним слоем фона. Фоны вложенных элементов перекрывают друг друга: чем глубже элемент, тем выше его фон. Для удобства ширину лучше задавать внешнему
элементу (т.к. все вложенные будут той же ширины), а высоту самому глубокому, т.к. он растянет по высоте всех своих родителей.*/
.block1 {
  width: 256px;
  margin: 0 auto;
  box-shadow: 1px 1px 3px #999999;
  background: url("") no-repeat;
}

.block2 {
  background: url("") no-repeat;
}

.block3 {
  height: 256px;
  background: url("") no-repeat;
}

/* новый способ (множественные фоны), нельзя задавать цвет */
.block {
  background:
    url("img1.png") no-repeat 0 0,
    url("img2.png") repeat-x 50% 50%,
    url("img3.png"); /* нижний слой */
}

/* декоративные элементы */
/* социальные кнопки:
- обычно ссылки на страницы компании в социальных сетях
- стилизация работающих «лайков» более сложная задача
- использовать блочно-строчный тип элемента
- вертикальное выравнивание по середине
- cпрайт общий для всех ссылок, фоновое изображение для класса social
- для уникальных классов соцсетей переопределим расположение фонового изображения и цвет фона
- CSS-правила для конкретных соцсетей расположены в коде ниже, чем правило, задающее общий вид, чтобы работало переопределение CSS-свойств
Задайте для класса .social фоновое изображение /assets/course14/social.png без повторения.
Цель 2Для класса .social-vk цвет фона #6d8fb3 и расположение фонового изображения 0 0.
Цель 3Для класса .social-fb цвет фона #526da3 и расположение -40px 0.
Цель 4Для класса .social-tw цвет фона #73bfe6 и расположение -80px 0. */
.social

/* переключатель страниц (paginator)
- разметка: один див, внутри которого расположены ссылки с номерами страниц и ссылки «Вперёд/Назад»
- иногда внутри переключателя используют спаны, например, для «многоточий»
- также переключатели иногда верстают списками
- зададим для ссылок и спанов блочно-строчный тип, размеры, внутренние отступы и фон
- задаём не ширину, а минимальную ширину min-width, т.к. номера страниц могут быть длинными: 1 и 1000
Теперь оформим текст переключателей.

Сначала зададим горизонтальное выравнивание по центру. Затем зададим вертикальное выравнивание по середине. Чтобы был виден эффект вертикального выравнивания, нужно задать высоту строки такую же, как высота элемента, т.е. 40px.

Затем зададим цвет ссылок, уберем подчеркивание и сделаем шрифт полужирным.
Займемся переключателями «вперед» и «назад». Пока что мы используем текстовые надписи. Но мы их спрячем и заменим на стрелочки.

Первым делом добавим к переключателям классы prev и next. Чтобы спрятать текст, используем свойство text-indent с большим отрицательным значением.

Затем отделим переключатели от номеров страниц с помощью отступов и с помощью уже знакомой техники спрайтов добавим на фон стрелочки. Вот спрайт на тёмном фоне:
Переключатель страниц почти готов. Но хороший верстальщик и хороший дизайнер всегда думают о мелочах.

В этом задании мы поработаем над состояниями элементов переключателя.

Первая очевидная деталь относится к номерам страниц. Надо как-то выделять текущую страницу. Для этого будем использовать класс current, для которого зададим зелёный фон.

Менее очевидная деталь относится к состояниям кнопок-стрелочек «вперед» и «назад». Когда мы находимся на первой странице, кнопка «назад» должна быть неактивна, а когда на последней странице — неактивна кнопка «вперед».

Оформим неактивные кнопки с помощью класса disabled, который будет делать кнопку полупрозрачной. */
.paginator {
  width: 280px;
  margin: 30px auto;
  padding: 10px;
  white-space: nowrap;
  background: #ecf0f1;
}

.paginator a,
.paginator span {
  display: inline-block;
  min-width: 20px;
  height: 40px;
  padding: 0 10px;
  background: #95a5a6;
  vertical-align: middle;
  text-align: center;
  line-height: 40px;
  color: white;
  text-decoration: none;
  font-weight: 700;
}

/* убираем текст, добавляем стрелочки */
.paginator .prev {
  text-indent: -1000px;
  margin-right: 20px;
  background-image: url("/assets/course14/arrows.png");
  background-repeat: no-repeat;
  background-position: 0 0;
}

.paginator .next {
  text-indent: -1000px;
  background-image: url("/assets/course14/arrows.png");
  background-repeat: no-repeat;
  margin-left: 20px;
  background-position: 0 -40px;
}

.paginator .current {
    background-color: #16a085;
}

.paginator .disabled {
    opacity: 0.3;
}

.paginator a:hover {
    background-color: #2ecc71;
}

/* пример оформления контактов
Заголовок и отступы сделали блок контактов более структурированным.

Отступы слева, как вы уже догадались, предназначены для размещения иконок.

Иконки будем размещать по одной из классических техник: «абсолютные элементы + спрайты».

В каждом из блоков .item есть пустой див .icon, в котором и будет отображаться иконка.

Специальные дивы в этом задании мы будем использовать для наглядности. Лучше иконки выносить в фон псевдоэлементов ::before и ::after, чтобы не «засорять» разметку.

Итак, давайте зададим этим дивам абсолютное позиционирование, фиксированные размеры и расположим в верхнем левом углу родителя (для этого мы задавали относительное позиционирование для .item).

Осталось задать для .icon картинку-спрайт в качестве фона. Вот она: */
.contacts {
    width: 250px;
    margin: 0 auto;
    margin-top :80px;
}

.contacts .title {
    font-size: 20px;
    font-weight: 700;
    color: #7f8c8c;
    margin-bottom: 20px;
}

.contacts .item {
    position: relative;
    padding-left: 30px;
    margin-bottom: 10px;
}

/* комментарии
Продолжаем работу. На этом шаге оформим сам текст комментария и дату комментария.

Обычно менее важную информацию стараются приглушить. Для этого используют следующие приёмы: уменьшают размер шрифта, задают менее контрастный цвет текста или сочетают эти эффекты. Простейшие CSS-свойства помогают эффективно расставлять акценты в дизайне.

В нашем случае дата комментария не столь важна, поэтому её и приглушим.
На этом шаге оформляем кнопку ответа на комментарий.

Все приёмы вам уже знакомы: кнопка будет абсолютно спозиционированным элементом с фиксированными размерами. На фон ей зададим иконку. Затем разместим кнопку в правом верхнем углу комментария.

Блок комментария обладает относительным позиционированием, поэтому проблем с размещением иконки не возникнет.
Сейчас подготовимся к позиционированию аватара.

Аватар будет располагаться в левом верхнем углу и частично перекрывать комментарий. Чтобы аватар не перекрыл имя автора и текст, мы увеличим паддинги слева у соответствующих элементов.

Мы увеличиваем отступ справа у автора, т.к. в правом верхнем углу комментария расположена кнопка ответа (спозиционированная абсолютно). Чтобы длинное имя автора не залезло под кнопку, мы и добавляем паддинг, размер которого чуть больше, чем кнопка.
Теперь осталось только задать аватару абсолютное позиционирование и разместить его сверху и слева.

Достаточно необычные комментарии, но способ их создания очень простой. */
.comment {
    position: relative;
    margin-top: 90px;
    margin-right: 20px;
    margin-left: 50px;
}

.comment-avatar {
    width: 70px;
    height: 70px;
    background: #7f8c8c url("/assets/course14/avatar.png") no-repeat 50% 50%;
}

.comment-author {
    margin-bottom: 5px;
    font-size: 16px;
    font-weight: bold;
}

.comment-text {
    padding: 12px;
    background-color: #f8f8f8;
    border-bottom: 5px solid #e5e6e6;
}

.comment-date {
    margin-top: 5px;
    font-size: 12px;
    color: #bdc3c7;
}

.comment-reply {
    position: absolute;
    top: 0;
    right: 0;
    width: 15px;
    height: 15px;
    background: url("/assets/course14/reply.png") no-repeat 0 0;
}

/* HACK: для растягивания меню на всю ширину блока через justify */

.menu {
  text-align: justify;
}

.menu::after {
  content: "";
  display: inline-block;
  width: 100%;
  height: 0;
}

.menu__item {
  display: inline-block;
  vertical-align: top;
}

/* HACK: выровнять содержимое с известными размерами по абсолютному центру (хорошо для иконок, например) */

.icon-img-pic {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  display: block;
  max-width: 100%;
  max-height: 100%;
}
